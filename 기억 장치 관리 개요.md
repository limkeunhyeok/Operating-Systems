# Operating System

## Charpter 06 주기억 장치 관리

- 기억 장치를 관리하는 운영 체제의 일부를 기억 장치 관리자(memory manager)라고 한다.
- 기억 장치 관리자의 역활은 기억 장치의 사용 여부를 조사하고, 할당 및 회수하는 일을 한다.

### 1. 주소 바인딩(address binding)

- 주소 바인딩이란 실행할 프로그램이나 데이터의 주소를 1차 기억 장치인 주기억 장치의 물리적 주소에 지정하는 일을 말한다.
- 정적 주소 바인딩(static address binding)이란 컴파일 시간, 링크 시간, 적재 시간 등의 처리 과정을 거쳐 주기억 장치의 물리적 주소를 생성하고 바인딩하는 것을 말한다.

![단계별수행과정](https://user-images.githubusercontent.com/38815618/86754739-14765b00-c07c-11ea-9a12-8332a888471d.PNG)

### 2. 동적 적재(dynamic loading) 및 동적 연결(dynamic linking)

- 동적 적재는 기억 장치의 효율을 높이려고 사용하는 방식이다.
  - 모든 루틴들이 재배치할 수 있는 주소 형태로 디스크 상에 존재하고 있다가 그 루틴이 호출되면 주기억 장치에 적재되는 방식을 가리킨다.
- 동적 연결에서는 링크 실행 시간까지 연기된다.
  - 스스로 루틴의 주소를 배치하고 루틴을 실행시킬 수 있는 작은 스텁(stub) 코드를 사용하기 때문이다.
- 동적 적재에서 사용되지 않는 루틴들은 주기억 장치에 적재되지 않는다.
  - 실제로 필요한 부분만 적재되어 주기억 공간을 절약하여 효율적이다.

### 3. 로더(loader)

- 바인딩은 프로그램을 코딩할 때 이루어지지만, 대부분 가상 기억 장치 시스템에서 바인딩은 로더로 프로그램을 실행할 때 이루어진다.
  - 사용자와 시스템의 융통성을 높여주는 대신에 복잡한 소프트웨어와 하드웨어를 요구한다.
- 로더는 프로그램과 데이터를 주기억 장치의 특정 위치에 적재하는 일을 담당하며 절대 로더(absolute loader)와 재배치 로더(relocatable loader)로 구분한다.
- 절대 로더는 기계어로 된 프로그램을 미리 지정된 주기억 장치 위에 적재하는 로더를 가리킨다.
- 재배치 로더는 적재 시간에 주기억 장치의 사용 여부에 따라 주기억 장치의 여러 다양한 곳에 적재하는 로더를 가리킨다.
- 기계어로 된 사용자 프로그램은 라이브러리 같은 외부의 기계어 코드와 결합하여야만 실행할 수 있는 단위가 되며, 이러한 결합 과정이 링킹 로더(linking loader)나 링킹 에디터(linkage editor)로 이루어진다.
- 링킹 로더는 프로그램을 적재할 때 필요한 프로그램들을 결합하여 이진 프로그램 이미지를 주기억 장치에 적재하는 것을 가리킨다.
- 링키지 에디터는 링킹 로더의 기능과 더불어 이진 프로그램 이미지를 디스크에 보관하는 역활을 담당한다.

### 4. 오버레이(overlay)

- 초기 시스템에서 사용자들은 기억 장치의 크기보다 큰 프로그램을 수행할 수 없었고, 이를 해결하는 일반적인 기법이 오버레이 또는 중첩이라고 불리는 기법이다.
- 오버레이는 디스크에 프로그램을 유지하고 운영 체제를 사용하여 기억 장치로 교체 시키는 방법이다.
- 기본적인 개념은 특정 시간에 필요한 코드와 데이터만을 부분적으로 기억 장치에 적재하고 앞으로의 실행에 더 이상 필요하지 않다면 다른 부분을 보조 기억 장치로부터 더 이상 필요하지 않는 곳에 적재하여 실행한다.

![오버레이구조](https://user-images.githubusercontent.com/38815618/86754724-117b6a80-c07c-11ea-8696-5703754960e7.PNG)

- 장점
  - 동적 적재에서처럼 오버레이는 운영 체제로부터 어떤 특별한 지원을 요구하지 않는다.
  - 사용자가 파일을 기억 장치 안으로 읽어 들이고 그 기억 장치로 분기하여 새로운 읽기 명령을 수행시키는 간단한 파일 구조를 사용함으로써 완전하게 구현할 수 있다.
  - 운영 체제는 평상시보다 더 많은 입출력이 있다는 사실만을 인식한다.
- 단점
  - 프로그래머는 오버레이 구조를 적절하게 설계하고 프로그램해야 한다.
  - 프로그래머는 코딩할 때 프로그램 구조, 코드 또는 자료 구조를 완전히 이해해야 한다.
  - 복잡한 오버레이 구조를 갖는 프로그램일 때에는 그 프로그램을 충분히 이해하기가 어렵고 수정하기가 어렵다.
  - 마이크로컴퓨터나 실제 기억 장치가 제한된 하드웨어에서는 중첩의 사용이 지원되지 않으므로 특수 시스템에 제한된다.

### 5. 스와핑(swapping)

- 프로세스가 기억 장치를 이동하는 작업을 스와핑 또는 교체 작업이라고 한다.
- 정상적으로 교체되어 나온 프로세스는 이전에 점유되었던 같은 주기억 장소의 공간 내로 교체될 것이며, 이러한 원칙은 바인딩 방법에 따른다.

![스와핑기법구조](https://user-images.githubusercontent.com/38815618/86754742-150ef180-c07c-11ea-80a0-15d694e4e082.PNG)

- 스와핑 과정
  - 프로세스 스케줄러는 임의의 프로세스의 수행을 결정할 때마다 디스패처(dispatcher)를 호출한다.
  - 디스패처는 준비 큐에 있는 수행할 다음 프로세스가 기억 장치 속에 존재하는지 확인하고, 현재 주기억 장치 속에 있는 하나의 프로세스를 디스크로 내보내고 수행하고자 하는 프로세스슬 주기억 장치로 불러들인다.
  - 정상 상태로 레지스터를 다시 적재하고 제어권을 CPU가 선택된 그 프로세스에게 넘긴다.
- 스와핑에서 사용자 프로세스는 입출력이 발생하거나 인터럽트가 발생할 때까지 파일을 점유하고 자신의 작업을 수행한다.
  - 다음 사용자 프로세스로 넘어갈 때 기억 장치의 현재 내용들이 보조 기억 장치에 기억되고, 다음 사용자를 위하여 주기억 장치에 읽혀 들어온다.
- 스와핑 기법은 비교적 적은 수의 사용자를 지원했던 초기의 시분할 시스템(TSS)에서 많이 사용한다.
  - 오늘날 페이징 시스템의 기초가 되었다.
- 스와핑 특징
  - 효과적으로 CPU를 사용하려면 각 프로세스의 전체 수행 시간이 교체되는 시간에 비해서 길어야 한다.
  - 드럼이나, 디스크와 같은 빠른 기억 장치를 요구한다.
  - 교체 방법은 주기억 장치의 크기가 제한되어 있을 때 유용하다.

![교체기법의구조](https://user-images.githubusercontent.com/38815618/86754736-13ddc480-c07c-11ea-9561-67c2252a7401.PNG)
