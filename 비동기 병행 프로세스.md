# Operating System

## Charpter 04 병행 프로세스와 상호 배제

- 프로세스 여러 개가 동시에 실행되면 병행 프로세스라고 한다.
- 병행 프로세스는 서로 관련없이 단독으로 작업을 수행하기도 하지만, 종종 다른 프로세스들과 협력, 통신하면서 작업을 진행해야 할 필요가 있다.
- 2개 이상의 프로세스들이 공유 메모리에 읽기/쓰기를 하고 그 결과가 어떤 프로세스가 언제 실행하느냐에 따라 결과가 달라질 수 있는 상황을 경쟁 조건(race condition)이라 한다.

### 1. 상호 배제와 임계 영역

> 만약 A 프로세스와 B 프로세스가 있다고 가정하자. A 프로세스가 값을 읽은 후, 읽고 쓰기 전에 B 프로세스를 읽는다면 문제가 발생한다. 이러한 문제를 해결하기 위해서는 A 프로세스가 값을 쓰기까지 B 프로세스가 기다려야 한다. A 프로세스는 공유 변수를 선언하기 전에 '지금부터 잠시 동안은 내가 사용하려는 공유 변수를 아무도 접근할 수 없다'고 선언해야 하고, 사용이 끝나면 '이제부터는 사용할 수 있다'라고 선언한다. 만일 그렇지 않다면 다른 프로세스가 공유 변수를 사용할 수 있는지 없는지를 알 수 없기 때문이다.

- 상호 배제(mutual exclusion)란 한 프로세스가 공유 메모리 혹은 공유 파일을 사용하고 있을 때 다른 프로세스들이 사용하지 못하게 배제시키는 제어 기법을 말한다.
- 프로세스는 때때로 공유 메모리나 공유 파일을 참조하여 경쟁 조건을 일으키는 일을 하며, 이러한 공유 메모리가 참조되는 프로그램의 부분을 임계 영역(critical section)이라 한다.
- 상호 배제 요구 조건
  - 상호 배제 조건: 두 개 이상의 프로세스들이 동시에 임계 영역에 있어서는 안 된다.
  - 진행 조건: 임계 구역 바깥에 있는 프로세스가 다른 프로세스의 임계 구역 진입을 막아서는 안 된다.
  - 한계 대기 조건: 어떤 프로세스도 임계 구역으로 들어가는 것이 무한정 연기되어서 는 안 된다.
  - 동일 속도 조건: 프로세스들의 상대적인 속도에 어떠한 가정도 하지 않는다.

#### 임계 영역이 있는 프로그램

```cpp
while (1) {
    // 임계 영역에 들어가기 전의 코드
    ...

    BeginCriticalSection();
    // 임계 영역 (critical section)
    ...

    EndCriticalSection();
    // 나머지 코드
    ...
}
```

- BeginCriticalSection()을 호출한 후에 다른 프로세스들이 임계 영역에 들어가려고 BeginCriticalSection()을 호출한다면 이미 프로세스 Pi가 임계 영역에 있으므로 그들은 대기하게 된다.
- 만일 2개 이상의 프로세스가 동시에 BeginCriticalSection()를 호출하면 이들 중 하나만이 임계 구역에 들어가고 나머지는 기다린다.
  - 이처럼 동시에 시도하여 임계 구역에 들어가는 프로세스를 승리자(winner)라고 한다.
  - 승리자는 무작위로 선택되어 기아 상태를 일으킬 수도 있고 한계 대기 조건을 만족시키게 선택될 수도 있다.

### 2. 2개 프로세스의 상호 배제

#### 소프트웨어적 해결 과정

- 변수 turn(정수형)은 2개 프로세스 P0, P1의 공유 변수이고, i는 프로세스 지역 변수이다.
- turn, i, j는 0 혹은 1의 값을 갖고 i=1-j이다.

##### 상호 배제 알고리즘 (1)

```cpp
while (1) {
    ...
    while (turn != i) ;
    // 임계 영역
    ...
    turn = j;
    // 나머지 코드
    ...
}
```

- turn 값이 i이면 Pi, j이면 Pj가 진입한다.
- turn = 0일 때 프로세스 Pj가 수행 중이 아니라도 두 번 연속해서 임계 영역에 들어갈 수 없다.
  - 이러한 문제를 락스텝 동기화(lock-step synchronization) 문제라 한다.

##### 상호 배제 알고리즘 (2)

- 알고리즘 (1)의 공유 변수 하나만 사용해서 발생하는 문제를 배열로 대치한다.

```cpp
while (1) {
    ...
    flag[i] = true;
    while (flag[j] == true) ;
    // 임계 영역
    ...
    flag[i] = false;
    // 나머지 코드
    ...
}
```

- 배열의 원소를 false로 초기화하고, flag[i]가 true라면 Pi가 임계 영역에 들어가겠다는 뜻이다.
- 이러한 방식은 진행 조건을 충족하지 않는다.
  - 2개의 프로세스가 거의 같은 시간에 진입하려고 하면 flag[i]와 flag[j] 모두 true가 되어 while 문에서 영원히 대기한다.
- 이렇게 2개의 프로세스가 상대방 flag가 false가 되기를 무한히 기다리는 상태를 교착 상태라고 한다.

#### 데커 알고리즘

- 두 프로세스 P0과 P1은 flag와 turn을 공유한다.

```cpp
while (1) {
    flag[i] = true;
    while (flag[j]) {
        if (turn == j) {
            flag[i] = false;
            while (turn == j);
            flag[i] = true;
        }
    }
    // 임계 영역
    ...
    turn = j;
    flag[i] = false;
    ...
}
```

- flag[0] = flag[1] = false이고 turn은 0 또는 1의 값을 갖는다.
- 두 프로세스가 동시에 진행하면서 flag를 true로 하고 상대방 flag를 검사한 다음, turn 값에 따라서 if 이하 절을 수행하거나 수행하지 않을 수도 있으며 결국 turn 값이 i이면 Pi가 진입하고 turn 값이 j이면 Pj가 진입하게 된다.
  - 따라서 한 프로세스는 두 번 연속해서 임계 구역에 진입할 수 있으나 세 번째는 다른 프로세스가 진입하게 된다.

#### 피터슨 알고리즘

- 두 프로세스 P0과 P1은 flag와 turn을 공유한다.

```cpp
while (1) {
    ...
    flag[i] = true;
    turn = j;
    while (flag[j] && turn == j);
    // 임계 영역
    ...
    flag[i] = false;
    ...
}
```

- flag[0] = flag[1] = false이고 turn은 0 또는 1의 값을 갖는다.
- 임계 영역에서 나오는 프로세스 Pi는 flag[i]를 false로 함으로 다른 프로세스가 임계 영역에 들어가게 허용한다.
  - 따라서 두 개의 프로세스가 동시에 진행할 때, 각각 자신의 flag를 true로 한 다음 Pi는 turn 값을 j로, Pj는 turn 값을 i로 하는데 내부 while 문에서 turn 값에 따라서 Pi나 Pj 중 하나가 임계 구역에 진입하게 된다.
