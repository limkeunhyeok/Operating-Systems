# Operating System

## Charpter 04 병행 프로세스와 상호 배제

### 1. 세마포어 연산

- 앞서 제시한 임계 영역의 문제는 더 복잡한 문제를 일반화시켜서 해결하기 어려우며, 다익스트라는 이를 극복하기 위해 세마포어(semaphore)라는 개념을 만들었다.
- 세마포어 s는 정수 값을 갖는 변수로서 초기화 및 2개의 연산(P와 V 혹은 wait와 signal)으로만 접근할 수 있는 특수한 변수이다.

```cpp
// wait(혹은 P)와 signal(혹은 V)의 정의
s.wait():
    if (s.value > 0) then
        s.value--;
    else
        현재의 프로세스를 s.list에서 기다린다.

s.signal():
    if (1개 이상의 프로세스가 s에서 대기 중이면) then
        그중 1개 프로세스만 진행
    else
        s.value++;
```

- wait 연산은 s 값에 따라 임계 구역에 진입하거나 대기한다.
- signal 연산은 대기 중인 프로세스를 재시작하게 해준다.
- wait와 siganl 연산이 세마포어 변수를 수정하는 것은 개별적으로 실행되며, 비분할 연산으로 간주해야 한다.
- 하드웨어 명령의 비분할 명령(indivisible instruction)이란, 그 명령이 수행되는 동안 인터럽트나 다른 사건(이벤트)으로 결코 명령이 중단되지 않는 것으로 이러한 명령어를 원자적(atomic) 명령이라고도 한다.

### 2. 세마포어를 이용한 상호 배제의 구현

```cpp
semaphore s(1);
while (1) {
    ...
    s.wait();
    // 임계 영역
    ...
    s.signal();
    ...
}
```

- 세마포어 변수 s에 적용된 wait와 signal 연산은 동시에 두 가지 동작이 실행되는 것을 예방하며, s는 세마포어 공유 변수이고 초기값은 1이다.

```cpp
semaphore s; // 공유 변수
s.init(1); // 초기화

또는

semaphore s(1);
```

- 만일 여러 개의 프로세스가 s.wait()를 동시에 호출해도 단 1개의 프로세스만이 s.wait()의 then 부분을 수행하고 나머지 프로세스들은 else 절을 수행한다.
- 구현 방법에 따라서 세마포어는 무한 대기 상황이 일어나지 않게 보장한다.

### 3. 세마포어를 이용한 동기화

- 한 프로세스가 입출력을 요구하면 입출력이 끝날 때까지 그 프로세스는 블록 상태가 되고, 다른 프로세스는 이 블록된 프로세스를 깨워야 하며, 이러한 것을 block/wakeup 프로토콜이라고 한다.

|wakeup 시킬 프로세스 P0|block 될 프로세스 P1|
|---|---|
|...<br>synch.signal();<br>...|...<br>synch.wait();<br>...|

- synch는 공유 변수이고, 0으로 초기화하면, P1 프로세스는 wait() 연산을 할 수 없고 P0 프로세스가 signal() 연산을 실행한 다음에만 수행될 수 있다.

### 4. 세마포어의 구현

- wait()를 호출한 프로세스는 CPU 자원을 반납하고 대기한다.
  - 즉, 블록 상태로 들어가고, 이때 PCB는 세마포어의 블록 리스트에서 대기한다.
- 다른 프로세스가 signal()을 호출해 주면 대기하고 있던 프로세스 중 하나는 블록 상태에서 준비 상태로 상태가 변화하고 CPU를 점유하려고 기다린다.(wakeup)

```cpp
class semaphore {
    public:
        wait();
        signal();
    protected:
        int value;
        PCB *list;
};
```

- 각 세마포어는 정수값과 프로세스 리스트를 갖는다.
- 프로세스가 세마포어에서 대기하도록 하려면 프로세스(PCB)를 리스트에 추가한다.
- signal()은 대기 프로세스의 리스트에서 한 프로세스를 꺼내어 실행하게 한다.
- 단일 처리기 시스템에서는 wait()와 signal()이 수행되는 동안 인터럽트를 금지함으로 간단디 비분할(indivisible) 명령을 구현할 수 있다.
- 다중 처리기 환경에서는 인터럽트의 금지가 허용될 수 없다.

### 5. 모니터

- 모니터(monitor)는 순차적으로만 사용할 수 있는 공유 자원 혹은 공유 자원 그룹을 할당하는 데 사용되며, 데이터, 프로시저를 포함하는 병행성 구조(concurrent construct)이다.
- 자원 관리 기능을 수행하려는 프로세스는 반드시 해당 모니터 진입부를 호출해야 한다.
- 모니터 자체는 상호 배제가 엄격하게 실시되어 1개의 프로세스만이 모니터 내부에 있을 수 있다.
  - 따라서 프로그래머는 동기화 제약 조건을 명시적으로 작성할 필요가 없다.
- 모니터 내부의 변수는 모니터 내부에서만 접근할 수 있다.(information hiding)
- 만일 프로세스가 모니터에 들어가서 수행 중에 자원이 이미 할당되어서 대기해야 하면 조건 변수의 wait()를 호출한다.
- 이 프로세스가 모니터 내부에 머물러 있으면 다른 프로세스의 진입을 허용할 수 없으므로 모니터 밖에서 signal()을 대기한다.

![모니터구조](https://user-images.githubusercontent.com/38815618/86361115-52573600-bcae-11ea-8b67-1f0769fa0504.PNG)

- 모니터는 여러 가지 측면에서 임계 구역과 비슷하다.
- 모니터는 추상 데이터 형태를 공유하기 위한 동기화 메커니즘을 제공한다.
- 기타 조건 변수 큐는 중단된 프로세스들이 대기하는 블록된 큐이다.
- next 큐는 signal해 주는 프로세스 혹은 블록 상태에서 풀린 프로세스가 대기하는 큐이다.
