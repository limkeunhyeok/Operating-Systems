# Operating System

## Charpter 03 프로세스와 스레드

### 1. 프로세스의 스케줄링

- 프로세스들이 작업을 수행하려면 프로세스 스케줄러로 CPU를 할당받아야 한다.
- 이러한 할당 작업은 운영체제로 구현되며 CPU들이 언제, 어느 프로세스에게 배당되는지 결정하는 작업을 프로세스 스케줄링이라고 한다.
- 스케줄링 분류
  - 기능별 분류
    - 작업 스케줄링
    - 프로세스 스케줄링
  - 방법별 분류
    - 선점 스케줄링
    - 비선점 스케줄링
  - 알고리즘별 분류
    - 우선순위 스케줄링
    - 기한부 스케줄링
    - FIFO 스케줄링
    - Round Robin 스케줄링
    - SJF(shortest job first) 스케줄링
    - SRT(shortest remaining time) 스케줄링
    - HRN(highest response ratio next) 스케줄링
    - MLQ(multi level queue) 스케줄링
    - MFQ(multi feedback queue) 스케줄링

#### 스케줄링의 목적과 기준

- 공정한 스케줄링
- 처리량 극대화
- 응답 시간 최소화
- 반환 시간 예측 가능
- 균형있는 자원 사용
- 응답 시간과 자원 이용 간의 조화
- 실행의 무한 연기 배제
- 우선순위제를 실시
- 바람직한 동작을 보이는 프로세스에게 더 좋은 서비스를 제공

#### 프로세스 스케줄링 기법

![프로세스_스케줄러](https://user-images.githubusercontent.com/38815618/86036218-85b07f80-ba78-11ea-9acd-fd0955bcedd8.PNG)

- 스케줄러는 준비 프로세스 혹은 스레드를 실행 상태로, 실행 프로세스 혹은 스레드를 준비 상태로 바꾸는 작업을 담당한다.
- 스케줄러는 간단하게 순서기, 디스패처, 문맥 교환기로 구성된다.
- 순서기는 프로세스를 준비 리스트에 넣는다.
- 디스패처는 프로세스에게 CPU를 할당한다.
- 문맥 교환기는 하나의 프로세스를 CPU로부터 제거하고 다른 프로세스를 넣는다.
- 문맥 교환은 CPU 레지스터에 저장된 한 프로세스의 상태 정보를 저장하고, 다른 프로세스를 위한 알맞은 정보를 레지스터로 쓰려는 연산이다.
  - 이 때 프로세스 디스크립터는 프로세스가 실행되지 않는 동안 CPU 레지스터의 복사본을 저장하려고 사용한다.

#### 선점 비선점 스케줄링

##### 선점 스케줄링

- 선점(preemptive)은 한 프로세스가 CPU를 차지하고 있을 때 다른 프로세스가 현재 프로세스를 중지시키고 자신이 CPU를 차지할 수 있을 때를 가리킨다.
- 선점 스케줄링 특징
  - 우선순위가 높은 프로세스가 먼저 수행될 때 유리하다.
  - 빠른 응답 시간을 요구하는 시분할 시스템에 유용하다.
  - 선점 때문에 많은 오버헤드를 초래한다.

##### 비선점 스케줄링

- 비선점(non-preemptive)은 한 프로세스가 CPU를 할당받으면 다른 프로세스는 CPU를 그 프로세스로부터 뺏을 수 없을 때를 가리킨다.
- 비선점 스케줄링 특징
  - 모든 프로세스의 요구를 공정히 처리한다.
  - 응답 시간을 예측할 수 있다.
  - 짧은 작업이 긴 작업을 기다리는 때가 종종 발생할 수 있다.

#### 스케줄링 알고리즘

##### 우선순위 스케줄링 - 비선점

- 우선순위(priority) 스케줄링이란 각 프로세스에게 우선순위를 부여하여 순위가 높은 순서대로 처리하는 방법을 말한다.
- 정적 우선순위 방법
  - 실행이 쉽고 상대적으로 오버헤드가 적다.
  - 주위 여견 변화에 적응하지 못하고 이에 대해서 우선순위를 바꾸지 않는다.
- 동적 우선순위 방법
  - 상황 변화에 잘 적응한다.
  - 구현하기 복잡하고, 오버헤드가 많다.
  - 시스템이 응답도를 증가시켜 주기 때문에 효율성 면에서는 좋은 편이 아니다.

![우선순위](https://user-images.githubusercontent.com/38815618/86036249-906b1480-ba78-11ea-90a3-4035a600e095.PNG)

- 우선순위가 높은 큐가 실행되어 프로세스가 라운드 로빈 방식으로 처리되고, 큐가 비게되면 다음 순위의 큐가 실행된다.
- 정적 우선순위 방법인 경우 가장 낮은 우선순위 프로세스는 기아 상태에 빠질 수 있다.

##### 기한부 스케줄링 - 비선점

- 기한부(deadline) 스케줄링은 작업들이 명시된 시간이나 기한 내에 완료되게 계획하여 처리하는 방법을 말한다.
- 사용자는 사전에 작업이 요구하는 정확한 자원을 제시해야 한다.
  - 하지만 그런 정보를 미리 예측하기가 매우 어려우며, 기한 시간 내에 일을 끝내지 못하면 막대한 손해가 초래된다.
- 시스템은 사용자들에 대한 서비스를 감소시키지 않으면서 기한부 작업을 실행할 수 있어야 하며, 기한까지 일을 끝내려고 작업의 안배를 주의 깊게 계획해야 한다.
  - 만약 많은 기한부 작업들이 동시에 실행된다면 스케줄링이 너무 복잡하게 되며, 기한부 스케줄링으로 요구되는 집중적인 자원 운영은 많은 오버헤드가 뒤따른다.

##### FCFS 스케줄링 - 비선점

- FCFS(First Come First Service) 스케줄링은 가장 간단한 방법으로, 프로세스들은 대기 큐에 도착한 순서에 따라 CPU를 할당받는다.

![FCFS](https://user-images.githubusercontent.com/38815618/86036251-9103ab00-ba78-11ea-8c52-555aada4a92f.PNG)

- 일단 프로세스가 CPU를 차지하면 완료될 때까지 수행된다.
- 다른 방식에 비하여 작업 완료 시간을 예측하기가 쉽다.
- 긴 작업이 짧은 작업을 오랫동안 기다리게 할 수 있으며, 중요하지 않은 작업이 중요한 작업을 기다리게 하므로 어느 정도 불합리하다.
- 대화식 사용자들에게는 적합하지 않다.

##### SJF 스케줄링 - 비선점

- SJF(Shortest Job First) 또는 SJN(Shortest Job Next) 스케줄링은 준비 큐에서 기다리는 작업 중이던, 큐에서 기다리는 작업 중이던, 수행 시간이 가장 짧다고 판단되는 것을 먼저 수행하는 방법이다.

![SJF](https://user-images.githubusercontent.com/38815618/86036237-8ea15100-ba78-11ea-8067-3343bd7eee9d.PNG)

- FCFS 보다 평균 대기 시간을 감소시키는 반면, 큰 작업에는 FCFS에 비하여 예측하기 어렵다.
- 긴 작업보다 짧은 작업이 오버헤드 면에서 볼 때 더 유리하다.
- 수행하게 될 작업이나 프로세스가 얼마나 긴 것인가를 정확히 알아야 하는데, 이 정보는 어렵고 최선의 방법은 수행 예측을 사용자에 의존하는 것이다.

##### HRN 스케줄링 - 비선점

- HRN(Highest Response ratio Next) 스케줄링은 SJF의 약점, 특히 긴 작업과 짧은 작업 간의 지나친 불평등을 어느 정도 보완한 기법이다.

![HRN](https://user-images.githubusercontent.com/38815618/86036253-9103ab00-ba78-11ea-9ad5-dfb5b19da8e4.PNG)

- 일단 한 작업이 CPU를 차지하면 그 작업은 완성될 때까지 실행한다.
- 긴 작업과 짧은 작업 간의 불평등을 어느 정도 완화시킨다.
- `우선순위 = (대기 시간 + 버스트 시간) / 버스트 시간 = 시스템 응답 시간`
- 짧은 작업이나 대기 시간이 큰 작업은 우선순위가 높아진다.

##### 라운드 로빈 스케줄링 - 선점

- 라운드 로빈(Round robin) 스케줄링은 FCFS로 프로세스들이 내보내지며 각 프로세스는 같은 크기의 CPU 시간을 할당받는다.
- 만약 프로세스가 CPU 시간이 만료될 때까지 처리를 완료하지 못하면 그 CPU는 대기 중인 다음 프로세스로 넘어가며, 실행중이던 프로세스는 준비 완료 리스트의 가장 뒤로 보내진다.

![라운드로빈](https://user-images.githubusercontent.com/38815618/86036244-8fd27e00-ba78-11ea-8fcb-836d26f048d5.PNG)

- 시분할 방식의 시스템에서 효과적이다.
- 할당 시간의 크기는 컴퓨터 시스템의 효과적인 동작에 절대적인 영향을 미친다.
- 할당 시간이 크면 FCFS 방식과 같다.
- 할당 시간이 작으면 자주 문맥 교환이 발생하므로 문맥 교환을 하려는 오버헤드가 커진다.

##### SRT 스케줄링 - 선점

- SRT(Shorest Remaining Time) 스케줄링은 SJF 스케줄링과 마찬가지로 새로 도착한 프로세스를 포함하여 처리가 완료된다.
- 준비 큐에 있는 프로세스들 중 가장 짧은 시간이 소요된다고 판단되는 프로세스를 먼저 수행시킨다.

![SRT](https://user-images.githubusercontent.com/38815618/86036242-8f39e780-ba78-11ea-80f0-9a3016c23fac.PNG)

- 현재 실행 중인 프로세스라도 남은 처리 시간이 더 짧다고 판단되는 프로세스가 준비 큐에 생기면 언제라도 실행 중인 프로세스가 선점될 수 있다.
- SJF 기법에 선점 방식을 도입한 변형된 방법으로서 시분할 시스템에 유용하다.
- 수행 중인 각각의 작업들의 실행 시간을 추적 보유하고 있어야 한다.(선점 때문에 오버헤드가 늘어난다)
- 긴 작업은 SJF보다 대기 시간이 길다.
- SRT에서의 대기 시간은 도착 시간에서 CPU를 할당받기까지 대기한 시간을 빼서 계산한다.

##### 다단계 큐 스케줄링 - 선점

- 다단계 큐(Multi Level Queue) 스케줄링은 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 스케줄링 기법이다.
- 그룹화된 작업들은 각각의 준비 큐에 넣어두고 각 큐의 독자적인 스케줄링 알고리즘에 따라서 CPU를 할당받는 방법이다.

![MLQ](https://user-images.githubusercontent.com/38815618/86036255-9234d800-ba78-11ea-8586-9d2a8ea20ce9.PNG)

- 다단계 큐 알고리즘은 준비 상태 큐를 여러 종류로 분할해 둔다.
- 각 큐는 자신만의 독자적인 스케줄링을 가지고 있다.
- 각각의 서로 다른 작업들이 다른 묶음으로 분류될 수 있을 때 사용되는 알고리즘 이다.
- 일괄 처리 작업이 실행 중일지라도 상위 단계 큐에 작업이 들어오면 일괄 처리 작업은 CPU를 내주어야 되므로 '선점'당해야 한다.
- 한 큐에서 다른 큐로의 작업 이동 불가 즉, 각 큐들 간에 작업 이동은 할 수 없다.

##### 다단계 피드백 큐 스케줄링 - 선점

- 다단계 프드백 큐(Multilevel Feedback Queue) 스케줄링에서는 입출력 위주와 CPU 위주인 프로세스의 특성에 따라 서로 다른 CPU의 타임 슬라이스를 부여한다.

![MFQ](https://user-images.githubusercontent.com/38815618/86036254-919c4180-ba78-11ea-8a1d-fb96f4d30bb7.PNG)

- 새로운 프로세스가 들어오면 높은 우선순위를 할당해 주어 단계 1에서 즉시 수행해 주고 점차 낮은 우선순위를 부여한다. 임의의 단계 n이 된 후에는 그 작업이 완료될 때까지 라운드 로빈으로 순환된다.
- 짧은 작업에 유리하다.
- 입출력 장치를 효과적으로 이용하려고 입출력 위주의 작업들에 우선권을 준다.
- 가능한 한 빨리 작업의 특성을 알고 그것에 맞게 해당 작업을 스케줄링 한다.
- 프로세스가 보다 하위 단계의 큐로 옮겨질수록 주어진 할당 시간은 점차 크게 설정된다.
  - 더 높은 단계에 있는 큐의 프로세스가 더 높은 우선순위를 갖기 때문이다.
- 이 기법은 CPU에 대한 요구량에 따라 프로세스들을 분류하는데 이상적이다.
- 시스템이 제어하는 동작의 변화에 민감하고 반응하게 하는 적용 기법의 일종이다.
- 한 큐에서 다른 큐로의 작업 이동을 할 수 없다.
- 다단계 피드백 큐 스케줄링은 아래와 같은 요소로 정의한다.
  - 큐의 수
  - 각 큐의 스케줄링 알고리즘
  - 작업을 더 높은 우선순위의 큐로 격상시키는 시기를 결정하는 방법
  - 작업을 더 낮은 우선순위의 큐로 격하시키는 시기를 결정하는 방법
  - 프로세스들이 어느 큐에 들어갈 것인가를 결정하는 방법

![스케줄링비교](https://user-images.githubusercontent.com/38815618/86036246-8fd27e00-ba78-11ea-886c-3f23008ce180.PNG)
