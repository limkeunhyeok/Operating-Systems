# Operating System

## Charpter 05 교착 상태

### 1. 교착 상태의 예방(deadlock prevention)

- 하벤더가 제시한 방안으로 교착 상태의 발생 가능성을 사전에 모두 제거하게 시스템을 조절하는 작업을 가리킨다.
- 교착 상태 발생 필요조건의 네 가지 중 하나를 부정함으로써 수행된다.

#### 점유와 대기 조건의 부정

- 점유와 대기 조건의 부정은 각 프로세스에서 필요한 자원들을 모두 한꺼번에 요청하고, 시스템에서는 요청된 자원들을 분석하여 한 프로세스가 요구한 자원을 전부 할당하든가 혹은 하나라도 부족하면 전혀 할당하지 않든지 하는 방식으로 자원을 할당하는 방법이다.
- 장점
  - 프로세스들이 자원을 기다리고 있는 동안은 아무 자원도 점유하고 있지 않으므로 점유와 대기 조건이 부정되며 교착 상태도 발생하지 않는다.
- 단점
  - 자원 낭비와 비용 증가를 초래한다.
  - 자원을 공유할 수 없다.
  - 자원이 부족한 상태에서 필요한 자원 모두가 동시에 사용할 수 없을 수도 있어서 어떤 프로세스는 끝내 필요로 하는 자원을 모두 얻지 못하는 문제가 발생한다.

#### 비선점 조건의 부정

- 비선점 조건의 부정은 어떤 자원을 가진 프로세스가 더 이상의 자원 할당 요구가 받아들여지지 않으면 원래 가지고 있던 자원을 일단 반납하고 필요하다면 다시 그 자원이나 다른 자원을 요구하는 방법이다.
- 문제점
  - '얼마나 자주 이러한 자원 반납을 행해야 하는가?'하는 점(비용 증가의 원인)
  - 무한 연기가 발생할 가능성이 있다는 점(시간 낭비의 원인)
  - 자원을 모두 얻지 못하는 상태가 발생할 수 있으며 특수한 자원을 사용할 때만 적용할 수 있다.

#### 환형 대기 조건의 부정

- 환형 대기 조건의 부정은 모든 프로세스에게 각 자원의 유형별로 할당 순서를 부여하는 방법이다.
- 만일 한 프로세스가 주어진 유형의 모든 자원을 할당받았으면, 그 프로세스는 순서에 따라 나중에 위치하는 유형의 자원만을 요구할 수 있게 한다.

![환형대기조건의부정](https://user-images.githubusercontent.com/38815618/86536692-8f2c6280-bf24-11ea-915a-81d51692ae57.PNG)

- 문제점
  - 자원에 번호를 부여할 때 실제로 프로세스가 실행 중에 자원을 사용하는 순서를 반영할 수 있어야 한다.
  - 새로운 자원이 시스템에 추가되면 현존하는 프로그램과 시스템을 재구성하여야 하는 번거로움이 있다.
  - 급한 프로그램이 발생할 때 자원 할당에 어려움이 발생한다.

#### 상호 배제 조건의 부정

- 상호 배제 조건 부정은 비공유를 전제로 한다.
- 공유 가능 전용 자원들은 배타적인 접근을 요구하지 않으므로 교착 상태로 될 수 없다.
  - 프로세스는 공유 가능 전용 자원을 대기할 필요가 없다.
- 프린터 등은 이에 해당하지만 기억 장치나 CPU는 공유할 수 있는 자원이며 상호 배제 조건을 따르지 않아도 된다.

### 2. 교착 상태의 회피(deadlock avoidance)

- 교착 상태가 발생하려고 할 때, 이를 적절히 피해가는 방법이다.
- 자원을 좀 더 효율적으로 이용하고자 하는 목적으로 예방보다는 좀 덜 엄격한 조건을 요구하게 한다.

#### 안전 상태와 불안전 상태

![시스템상태](https://user-images.githubusercontent.com/38815618/86536690-8dfb3580-bf24-11ea-8bc4-ffc76c7e347d.PNG)

- 안전한(safe) 상태: 시스템이 특정한 순서대로 각 프로세스에게 자원을 할당할 수 있고 교착 상태를 방지할 수 있는 상태
- 불안전(unsafe) 상태: 교착 상태가 발생할 수 있는 상태

#### 은행가 알고리즘

- 다익스트라가 제안한 교착 상태를 회피하기 위한 방법이다.
- 각 프로세스에 자원을 어떻게 할당할 것인가라는 정보가 필요하므로, 각 프로세스가 요청하는 자원 종류의 최대수를 알아야 한다.
- 은행가 알고리즘에서 운영체제는 안전 상태를 유지할 수 있는 요구만을 수락하고 불안전 상태를 초래할 사용자의 요구는 나중에 만족될 수 있을 때까지 계속 거절한다.
- 은행가 알고리즘에서 n을 시스템의 프로세스 수라 하고, m을 자원 형태의 수라 한다면 다음과 같은 자료구조가 필요하다.
  - Available: 각 자원의 형태별로 사용할 수 있는 자원의 수를 표시하는 길이가 m인 벡터(잔여량)
  - Max: 각 프로세스의 최대 자원의 요구를 표시하는 n x m 행렬(최대 요구량)
  - Allocation: 현재 각 프로세스에게 할당된 자원의 수를 정의하는 n x m 행렬(할당량)
  - Need: 각 프로세스의 남아 있는 자원의 요구를 표시하는 n x m 행렬(추가 요구량, 필요량)

### 3. 교착 상태의 발견(deadlock detection)

- 여러 시스템에서 사용되는 방법으로, 일단 원하는 것이든지 아니든지 교착 상태가 발생하게 허용한 후에 교착 상태가 일어났는지를 판단하고 그 교착 상태에 관련된 프로세스와 자원을 조사하여 교착 상태를 시스템으로부터 제거하는 기법이다.
- 교착 상태를 중단시키기 위해서 프로세스 일부는 종료시켜야 하는 문제점이 있을 수 있고, 검사점(checkpoint)에서의 정보가 유용하다면 교착 상태 초기 단계에서부터 복귀될 수도 있다.

### 4. 교착 상태의 회복(recovery from deadlock)

- 시스템으로부터 교착 상태를 제거하여 이후로 시스템이 교착 상태에 빠지지 않고 잘 진행되게 하는 기법이다.
- 교착 상태의 회복하려는 방법으로 1개 이상의 프로세스를 중지시키거나, 교착 상태의 프로세스로부터 자원을 선점시킨다.

#### 프로세스 중지

- 프로세스를 모두 중지하는 방법
  - 확실하게 교착 상태의 사이클을 해결한다.
  - 현재까지 수행한 결과를 모두 잃어버려 다시 재연산을 해야 할 수 있기 때문에 많은 비용이 초래된다.
- 교착 상태 사이클이 제거될 때까지 한 프로세스씩 중지하는 방법
  - 매번 각 프로세스가 중지될 때마다 교착 상태 발견 알고리즘을 호출하여 프로세스들이 아직도 교착 상태에 있는가를 확인해야 하므로 부담이 크다.

#### 자원 선점

- 프로세스로부터 자원들을 선점하여 이들 자원을 교착 상태가 해결될 때까지 다른 프로세스들에게 할당한다.
- 희생자 선정 문제
  - 어느 자원을 선점시키고 어느 프로세스를 희생시킬 것인가를 결정해야 하는 문제
- 복귀(rollback) 문제
  - 어느 정도의 시간 동안 복귀시켜야 하는가 하는 기간을 결정하는 문제
  - 자원을 선점하면 필요 자원이 부족하므로 정상 실행을 할 수 없다.
- 기아 상태(starvation) 문제
  - 자원들이 항상 같은 프로세스로부터 선점된다면 기아 상태가 발생할 수 있으며, 어느 한 프로세스가 반복적으로 희생자로 선정될 수 있다.

#### 교착 상태 회복의 문제점

- 시스템이 교착 상태인지를 알기가 어렵다.
- 대부분의 시스템은 프로세스를 무기한 정지시키고 이를 시스템에서 제거한 후 다음에 다시 계속하게 하는 기능이 거의 없다.
- 효율적인 중단/재시작 기능이 있다 하더라도 여기에는 상당한 추가 부담이 든다. 그리고 숙련된 조작자를 요구하는 것이 대부분이나 그러한 조작자가 항상 있는 것은 아니다.
- 소규모의 교착 상태로부터 회복하려 하여도 많은 일을 요구하므로, 대규모의 교착 상태일 때에는 더 많은 양의 일을 요구한다.
- 교착 상태에 있는 프로세스들의 우선순위가 없어서 조작자가 임의로 결정을 내려야 할 때도 있다.
- 최적의 프로세스를 선택하여 제거하려는 결정이 현실적으로 매우 어렵다.
