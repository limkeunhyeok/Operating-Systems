# Operating System

## Charpter 06 주기억 장치 관리

### 1. 순수 페이징 주소 변환

- 페이징 기법(paging)은 컴퓨터가 주기억 장치에서 사용하기 위해 2차 기억 장치로부터 데이터를 저장하고 검색하는 메모리 관리 기법이다.
- 즉 가상 기억 장치를 모두 같은 크기의 블록으로 편성하여 운용하는 기법이다.
  - 이때의 일정한 크기를 가진 블록을 페이지(page)라고 한다.

#### 순수 페이징 주소 변환

![순수페이징](https://user-images.githubusercontent.com/38815618/87051962-38cc6600-c23b-11ea-8f94-7bb531a0b407.PNG)

- 페이징에서 주소 변환 과정
  - 가상 주소의 최상위 비트 g를 페이지 테이블에 보낸다.
  - 페이지 변환 함수인 Bt의 연산 결과에 만약 페이지 Pi가 현재 올려져 있지 않으면 Bt(Pi) = {Ω}로 페이지 부재가 발생하고 별도의 페이지 부재 처리를 한다.
  - 만약 페이지가 Bt(Pi) = bj에 적재되었다면 bj는 페이지 프레임 번호이다. bj는 물리 주소의 최상위 부분에 적재된다.
  - 오프셋에 해당하는 행 번호 V는 물리 주소의 최하위 부분에 적재된다.
  - 변환된 물리 주소는 주기억 장치로 보내려고 메모리 주소 레지스터 MAR로 전달된다.

#### 페이지 부재 처리

- 수행 중인 프로세스가 페이지를 참조하여 그 페이지가 주기억 장치에 없으면, 페이지 부재가 발생하고 운영 체제는 디스크로부터 해당되는 페이지를 적재하여, 페이지 테이블을 갱신한 후 물리 주소로 변환하게 된다.
- 운영 체제로 페이지 부재를 처리하는 과정
  - 프로세스가 페이지를 참조한다. 페이지 부재를 발생시킨 프로세스는 중단된다.
  - 페이지 보호 비트를 검사한다.
  - 기억 장치 관리자는 보조 기억 장치에서 가용 페이지를 찾는다.
  - 페이지가 주기억 장치에 적재되고 상황에 따라 다른 페이지가 해제되기도 한다.
  - 기억 장치 관리자의 페이지 테이블은 갱신된다.
  - 프로세스는 중단되었던 시점에서 다시 시작된다.

### 2. 연관 사상/순수 페이징 혼용 방법

#### 연관/순수 페이징을 혼용한 주소 변환

- 연관 사상(associative mapping) 방법은 빠른 주소 변환을 수행하려고 위치 지정(location addressed)이 아닌 내용 지정(content addressed)의 연관 기억 장치에 사상 페이지 테이블을 유지한다.
  - 이때 두 번의 기억 장치 접근 문제가 발생하는데, 이는 연관 기억 장치 또는 변환 버퍼(Translation Look-aside Buffers, TLBs)라고 하는 특별한 하드웨어 캐쉬(fast-lookup hardware cache)를 사용함으로써 해결한다.
- 연관 사상 페이징 기법의 특징
  - 주기억 장치보다 훨씬 빠른 접근 시간을 가지는 연관 기억 장치에 페이지 사상표 전체를 넣는 방법으로서 가장 빠르고 융통성 있는 사상 구조이다.
  - 순수 연관 사상은 모든 사상표를 연관 기억 장치에 넣으므로, 직접 사상보다 구현하기가 어렵다.
  - 연관 사상 = 페이지 번호 * 연관 사상표
  - 연관 기억 장치는 캐쉬에 비해 매우 비싸므로 순수한 연관 사상은 잘 사용되지 않는다. 그렇기 때문에 연관 기억 장치의 이점과 순수 페이징의 이점을 취할 수 있는 혼용 방법이 필요하다.

![연관순수페이징](https://user-images.githubusercontent.com/38815618/87051967-3964fc80-c23b-11ea-8c95-2f204d5d47e7.PNG)

- 연관 순수 페이징을 혼용한 동적 주소 변환 과정
  - 먼저 프로세스는 가상 주소 G = (p, d)를 참조하여 연관 기억 장치 변환 버퍼를 먼저 탐색한다.
  - 만약 페이지 p가 변환 버퍼에 있다면 곧바로 p' + d를 계산하여 실주소 k를 생성한다.
  - 만약 페이지 p가 변환 퍼버에 없다면 페이지 테이블을 탐색하여 직접 사상 방법으로 실주소 k를 생성한다.
    - 이때 변환 버퍼는 이 정보를 포함하게 갱신한다.

### 3. 페이지 테이블 구조

#### 계층 구조 페이지 테이블(hierarchical page tables)

- 계층 구조 페이지 테이블은 가상 주소 공간을 여러 단계의 페이지 테이블로 나누는 것이다.

![2단계테이블구조](https://user-images.githubusercontent.com/38815618/87051961-3833cf80-c23b-11ea-825c-55c311d27fd1.PNG)

- P1은 외부 페이지 테이블이과 P2는 외부 페이지 테이블 내에서의 오프셋 또는 변위가 된다.
- 주소 변위 과정은 P1으로부터 외부 페이지 테이블을 찾고, P2로 각 페이지 테이블을 찾고 해당 페이지 테이블에서 찾는 프레임 주소에 변위 d를 더하여 물리 주소를 계산한다.

#### 해시 페이지 테이블(hashed page tables)

- 해시 페이지 테이블은 보통 주소 공간이 32비트 이상일 때 사용한다.

![해시페이지테이블](https://user-images.githubusercontent.com/38815618/87051960-3833cf80-c23b-11ea-8cf3-9524d6109a54.PNG)

- 주소 변환 과정
  - 가상 주소 공간으로부터 페이지 번호가 오면 그 번호를 해싱한다.
  - 해시 테이블에서 연결 리스트를 따라가며 첫 번째 노드의 가상 페이지 번호가 일치되는지 비교한다.
  - 일치되는 페이지 번호를 찾으면 그에 대응하는 두 번째 필드의 페이지 프레임 번호에 변위를 더하여 해당 페이지 프레임의 물리 주소를 계산한다.
  - 일치하지 않으면 연결 리스트 두 번째 노드부터 비교하는 과정을 반복한다.

#### 역 페이지 테이블(inverted page tables)

- 역 페이지 테이블은 기억 장치의 실제 페이지 프레임당 각각 하나의 항목씩 할당하고, 각 항목은 그 페이지를 소유하는 프로세스의 정보(process id)와 함께 주기억 장치에 저장된 페이지의 가상 주소로 구성된다.

![역페이지테이블](https://user-images.githubusercontent.com/38815618/87051965-3964fc80-c23b-11ea-9d12-5f37ce14dca9.PNG)

- 역 페이지 테이블의 특징
  - 논리 페이지마다 항목을 가지는 대신 물리 프레임에 대응하는 항목만 테이블에 저장하므로 기억 장소가 절약된다.
  - 테이블 전체를 검색, 탐색하므로 시간이 소요된다.
  - 페이지 테이블 항목 검색 시간을 줄이려고 해시 테이블을 사용한다.
- 주소 변환 과정
  - Pid와 페이지 번호 p를 사용하여 페이지 테이블을 검색한다.
  - 일치되는 페이지를 찾으면 색인에 변위를 더하여 해당 페이지 프레임의 물리 주소를 계산한다.

### 4. 페이지 시스템의 공유

- 특히 시분할 시스템에서 여러 사용자가 같은 프로그램을 수행할 때, 주기억 장치의 낭비를 방지하기 위해 공유가 가능한 페이지를 사용한다.

![페이지시스템공유](https://user-images.githubusercontent.com/38815618/87051955-3702a280-c23b-11ea-9431-830274c24db2.PNG)

- 세 개의 프로세스 P1, P2, P3가 편집기 1, 2, 3의 물리 주소를 갖도록 함으로써 공유하고 있다.
- 공유는 필요한 주기억 장치의 양을 줄이는 동시에 더 많은 사용자가 쓸 수 있게 해준다.
