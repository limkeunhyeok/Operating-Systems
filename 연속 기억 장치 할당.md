# Operating System

## Charpter 06 주기억 장치 관리

### 1. 단일 사용자 연속 기억 장치 할당

- 단일 사용자 연속 기억 장치 할당 방법은 모든 프로그램의 크기는 주기억 장치의 용량을 초과할 수 없으며 한 순간에 오직 1명의 사용자만이 주기억 장치를 전용하여 사용하므로 다른 모든 사용자는 기다려야 하는 방법이다.

![단일사용자전용메모리할당](https://user-images.githubusercontent.com/38815618/86899255-be211f00-c144-11ea-9191-c2d9d21d0a4a.PNG)

- a ~ c 번지만큼의 영역만 사용자가 사용할 수 있다.(
- CPU가 기억 장치를 참조할 때, 운영 체제 영역을 참조했는지 조사하려면 경계 레지스터를 검사하면 된다.
- 만일 운영 체제 영역을 침범하였다면 인터럽트를 발생시키고, 운영 체제에게 제어권을 넘겨준다.
- 단일 사용자 연속 기억 장치 할당 방법의 특징
  - 단순하며 이해하기 쉽다.
  - 기억 장치의 빈 공간들을 이용하지 못해서 기억 장치의 낭비가 심하다.
  - 한 사용자만이 기억 장치를 전용하므로 주변 장치 등 자원의 낭비가 심하다.
  - 입출력을 수행하는 동안 CPU는 사용하지 않고 있어 CPU 시간의 낭비가 크다.
  - 특별히 사용되지 않는 프로그램도 계속 기억 장치 내에 위치하고 있어야 한다.
  - 오버레이 기능이 없을 때는 여분의 기억 공간보다 작은 프로그램만 수행할 수 있다.

### 2. 고정 분할 기억 장치 할당

- 고정 분할 기억 장치 할당은 주기억 장치를 일정 수의 고정된 크기들로 분할하여 실행 중인 여러 프로세스에게 할당하는 기법을 말한다.
  - 여기서 분할(partition)이란 하나의 단일 작업이 적재될 수 있는 일정한 크기의 기억 장치 영역으로, 다중 프로그래밍의 정도는 분할의 수로 제한을 받는다.

#### 절대 번역과 적재(absolute compile & loading)

- 절대 번역과 적재는 초기의 다중 프로그래밍 시스템에서 사용한 방법으로 지정된 분할만 사용한다.

![절대번역적재](https://user-images.githubusercontent.com/38815618/86899246-bceff200-c144-11ea-8bf0-15e3a19723f9.PNG)

- 주기억 장치가 여러 개의 고정된 분할로 나뉘어져 있고, 하나의 작업은 절대 어셈블러와 절대 컴파일러로 번역되어서 지정된 분할에서만 실행될 수 있다.
- CPU는 작업들 사이를 빠르게 옮겨 다니면서 동시에 여러 작업을 수행하는 것처럼 느껴지게 한다.
- 절대 번역과 적재는 주기억 장치의 낭비를 가져오지만 운영 체제는 비교적 간단하고, 구축하기 쉽다.

#### 재배치 번역과 적재(relocation compile & loading)

- 재배치 번역과 적내는 모든 작업을 하나의 작업 큐에 넣어서 어느 분할에서든지 실행 가능하게 한 기법이다.

![재배치번역적재](https://user-images.githubusercontent.com/38815618/86899243-bbbec500-c144-11ea-853a-26ef1af79051.PNG)

- 절대 번역과 적재 기법보다 주기억 장치의 낭비를 줄였지만, 운영 체제가 조금 복잡해졌다.

#### 고정 분할 기억 장치 할당에서의 보호

- 고정 분할 기억 장치 할당에서의 보호는 여러 개의 경계 레지스터를 사용하여 보호한다.
- 경계 레지스터는 합당한 사용자 주소 범위를 나타내는 하한 레지스터와 상한 레지스터로 되어 있다.

![고정분할기억장치할당보호](https://user-images.githubusercontent.com/38815618/86899251-bd888880-c144-11ea-9621-5b17f1771b20.PNG)

#### 고정 분할 기억 장치 할당에서의 단편화

- 고정 분할 기억 장치 할당을 운영할 때 고려해야 할 문제 중 하나는 분할의 크기를 결정하는 것이다.
  - 이러한 결정은 일반적으로 프로그램의 기억 장치 요구량에 대한 과거의 관행과 경험을 기초로 결정할 수 있다.

##### 기억 장치 단편화(fragmentation)

- 기억 장치 단편화는 기억 장치의 구성에 관계없이 모든 컴퓨터 시스템에서 발생한다.
- 기억 장치 단편화는 작업의 크기가 분할에 맞지 않아 대기 중인 어떤 작업도 이 분할에 적재될 수 없을 때에 발생하며, 사용될 수 없는 여분의 기억 공간을 가리킨다.

![기억장치단편화](https://user-images.githubusercontent.com/38815618/86899254-bd888880-c144-11ea-9296-c92be05b1e0a.PNG)

- 내부 단편화(internal fragmentation)이란 하나의 분할에 작업을 할당하고 남은 공간을 말한다.
- 외부 단편화(external fragmentation)이란 대기 중인 작업에게는 분할이 너무 적어 분할 전체가 공간으로 있을 때의 상태를 말한다.

### 3. 가변 분할 기억 장치 할당

- 가변 분할 기억 장치 할당은 주기억 장치의 다중 프로그래밍 기법으로, 단편화 현상을 줄이려고 가장 합리적인 분할의 크기를 결정하여 각 작업에게 주기억 장치를 할당하는 기법을 말한다.
- 이 방법은 고정된 분할의 경계를 없애고, 각 작업에 필요한 만큼의 기억 장치를 할당시킨다.

#### 기억 장치 배치 전략

##### 최초 적합 전략(first fit strategy)

- 프로그램이 적재될 수 있는 가용 공간 중에서 첫 번째 분할에 할당(배치)하는 방식을 말한다.
- 공간을 찾으려고 기억 장치 전체를 조사하지 않아도 돼서 배치 결정을 빨리 내릴 수 있다.
- 사용되지 않은 작은 크기의 가용 공간이 누적되는 때 할당 결정이 늦을 수 있다.

##### 최적 적합 전략(best fit strategy)

- 가용 공간 중에서 프로그램을 적재할 수 있는 가장 작은 공백이 남는(적합한) 분할에 할당한다.
- 가용 공간을 반만 탐색해도 필요한 공간을 찾을 수 있다.
- 가용 공간 리스트가 크기순으로 되어 있지 않으면 전 리스트를 검색해야만 하기 때문에, 사용하다가 남은 기억 장소를 크기 순서로 배열하는 많은 시간이 요구된다.
- 할당 후 작은 가용 공간을 또 만들어 낸다.

##### 최악 적합 전략(worst fit strategy)

- 프로그램의 가용 공간들 중에서 가장 큰 공간에 배치하는 방법이다.
- 큰 가용 공간에 프로그램을 할당해서 남은 공간도 여전히 크므로 큰 다른 프로그램을 실행할 수 있다.
- 가용 공간 리스크가 크기순으로 되어 있지 않으면 전 리스트를 검색해야만 한다.
- 큰 프로그램을 적재할 가용 공간이 없어진다.

#### 기억 공간의 효율화

- 가변 분할 기억 장치 할당에서 초기에는 별다른 기억 장치의 낭비가 없다.
- 작업이 끝나고 실행을 기다리는 작업들에게 공백을 할당했을 때부터 기억 장치의 단편화가 발생하고, 단편화 현상은 시간이 지날수록 증가될 가능성이 높다.

![가변분할할당단편화](https://user-images.githubusercontent.com/38815618/86899248-bceff200-c144-11ea-8e11-3b4f6c3da983.PNG)

##### 공백의 통합

- 쓰레기 수집(garbage collection)은 가용 공간을 모아서 하나의 큰 가용 공간을 만들어 가용 공간에 반납하는 것을 말한다.
- 기억 장치 통합(memory coalescing)은 이웃되는 가용 공간을 하나의 커다란 가용 공간으로 만드는 것을 말한다.
- 공백의 통합이란 기억 공간에 공백이 발생하였을 때, 가변 분할 다중 프로그래밍은 그 공백이 비어있는 다른 기억 공간과 인접되어 있는지 점검하여 인접한 공백들과 결합하여 기억 공간을 만드는 것을 말한다.
- 빈 기억 장소 리스트에 새로운 공백으로 기록할 수도 있다.
- 이미 있는 공백과 새로운 인접한 공백을 합병하여 하나의 공백으로 기록할 수도 있다.

##### 기억 장치 집약

- 기억 장치 집약(compaction)이란 현재 사용되는 모든 기억 공간을 주기억 장치의 한쪽 끝으로 옮김으로써, 존재하는 여러 개의 작은 공간들을 하나의 커다란 기억 공간으로 집약하는 것이다.
- 시스템의 실행 환경에 따라 그 집약에 소요되는 작업 이동 비용이 달라질 수 있다.
- 생산적으로 사용될 수 있는 시스템 자원을 낭비할 수도 있다.
- 시스템은 집약이 실행되는 동안 모든 일을 중지한다. 이는 대화형 시스템이나 실시간 시스템에 일정치 않은 응답 시간을 주게 되고 치명적인 시스템의 장애 요인이 될 수 있다.
- 집약할 때 기억 장치 내의 작업 환경은 급격히 변화되므로 자주 집약을 해야 하기 때문에 잦은 집약으로 시스템의 자원을 소모하게 된다.
- 집약할 때 작업을 이동하려고, 프로그램이 적재될 때 없애 버리는 재배치 관련 정보(reloction information)를 유지, 보관하고 있어야 한다.
